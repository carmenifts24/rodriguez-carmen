# -*- coding: utf-8 -*-
"""001_Python_para_PLN.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1G2ovnC0Bs7t5M3cNAHSCWZ98hYWgqkKP

üßë‚Äçüè´ OBJETIVO DID√ÅCTICO DE LA ACTIVIDAD PROPUESTA

Introducir los fundamentos de Python con aplicaciones pr√°cticas orientadas al procesamiento del lenguaje, desde una visi√≥n de ciencias de datos e inteligencia artificial.

Esta clase tiene como foco desarrollar:

Competencia	---------------------->Aplicaci√≥n en PLN

Variables y tipos	------------------->Almacenar y manipular texto

Condicionales y operadores-------->Clasificar frases o palabras

Estructuras de datos--------------->Representar documentos, vocabularios o frecuencias

Bucles y control	------------------->Recorrer textos palabra por palabra

# Clase 1: Fundamentos de Python üêç - Herramientas para Ling√ºistica Computacional

## ¬øQu√© Haremos Hoy?
1.  **Variables:** Las "cajas" para guardar informaci√≥n.
2.  **Tipos de Datos:** ¬øQu√© guardamos en esas cajas? (Texto, n√∫meros, etc.).
3.  **Operadores:** C√≥mo hacer cosas con nuestros datos.
4.  **Condicionales:** C√≥mo hacer que nuestro programa tome decisiones.

## 1. Variables: Nuestras "Cajas" con Nombre

Una variable es simplemente un contenedor donde guardamos un dato para usarlo m√°s tarde. Le damos un nombre para poder referirnos a ella.

**Reglas para los nombres:**
* No pueden empezar con un n√∫mero.
* No pueden tener espacios (usa `_` en su lugar, como `mi_variable`).
* No uses palabras que Python ya reserva para s√≠ mismo (como `print`, `if`, etc.).
"""

saludo = "Hola, mundo del PLN!"
print(saludo)

# Definimos una variable 'saludo' que contiene una cadena de texto (string).
# Esta variable podr√≠a representar una oraci√≥n en un corpus textual.
# Usamos print() para visualizar el contenido de la variable.

saludo_uno = "Hola Carmen, comencemos a estudiar"

print(saludo_uno)

"""## 2. Tipos de Datos: ¬øQu√© hay dentro de las cajas?

No todos los datos son iguales. Python distingue principalmente entre:

* **String (`str`):** Texto, siempre entre comillas (`" "`). ¬°El tipo de dato m√°s importante para nosotros en PLN!
* **Integer (`int`):** N√∫meros enteros (ej: `10`, `-5`).
* **Float (`float`):** N√∫meros con decimales (ej: `3.14`).
* **Boolean (`bool`):** Representa la verdad. Solo puede ser `True` o `False`.

Para saber qu√© tipo de dato tiene una variable, usamos la funci√≥n `type()`.
"""

# Definimos tres variables con distintos tipos de datos:
# - 'oracion' es un string (texto)
# - 'cantidad_de_palabras' es un entero (int)
# - 'es_interesante' es un booleano (bool)
# En PLN, es clave saber si estamos tratando con texto, n√∫meros o valores l√≥gicos.


# Variable de tipo String
oracion = "El an√°lisis de texto es fascinante."

# Variable de tipo Integer
cantidad_de_palabras = 6

# Variable de tipo Boolean
es_interesante = True

# Usemos type() para verificar
print(type(oracion))
print(type(cantidad_de_palabras))
print(type(es_interesante))

"""> **Nota importante:** ¬øPor qu√© nos importa el tipo de dato? Porque define qu√© operaciones podemos hacer. Por ejemplo, podemos `sumar` dos n√∫meros, pero no podemos `dividir` un texto. `type()` es nuestro mejor amigo para no cometer errores.

## 3. Operadores: Haciendo Cosas con los Datos

Podemos combinar y comparar nuestras variables usando operadores.

* **Operador `+` con texto:** Une (concatena) dos strings.
* **Operadores de comparaci√≥n (`==`, `!=`):** Preguntan si dos valores son iguales o diferentes. ¬°Siempre devuelven un Booleano (`True` o `False`)!
"""

# Usamos el operador '+' para concatenar (unir) strings.
# Esto es muy com√∫n en PLN cuando armamos oraciones o tokens.

palabra1 = "procesamiento"
palabra2 = "lenguaje"

# Unimos las palabras con un espacio en medio
frase_completa = palabra1 + " de " + palabra2
print(frase_completa)

print(palabra1, 'de', palabra2)

palabra3 = "Procesamiento"

palabra1 == palabra3

# Comparemos dos n√∫meros
numero_a = 10
numero_b = 20
print("¬øSon iguales numero_a y numero_b?")
print(numero_a == numero_b) # Esto imprimir√° False

"""## 4. Condicionales: Tomando Decisiones

Los condicionales `if`, `elif` y `else` permiten que nuestro programa ejecute cierto c√≥digo solo si se cumple una condici√≥n.

La **indentaci√≥n** (el espacio al principio de la l√≠nea) es MUY importante. Le dice a Python qu√© c√≥digo pertenece al `if`.
"""

# Creamos una estructura condicional que responde diferente seg√∫n la palabra ingresada.
# Esto imita procesos de clasificaci√≥n textual b√°sica: si es "Python", decimos algo espec√≠fico.


# Pedimos al usuario que escriba una palabra
palabra_usuario = input("Escrib√≠ una palabra clave (ej: Python): ")

# El programa decide qu√© hacer bas√°ndose en la palabra
if palabra_usuario == "Python":
    print("¬°Genial! Ese es el lenguaje que estamos aprendiendo.")
else:
    print("Esa es una palabra interesante, ¬°pero no es Python!")

variable_tmp = float(input('Ingres√° un numero del 1 al 10: '))

type(variable_tmp)

"""## Ejercicio Pr√°ctico 1: Analizador Simple de Frases

> A√±adir blockquote



¬°Es hora de poner a prueba lo que aprendimos! Vamos a crear un programa que analice una frase que ingrese el usuario y nos diga algunas cosas sobre ella.

**Consigna:**

1.  Ped√≠ al usuario que ingrese una frase usando `input()`.
2.  Verifica si la palabra "Python" est√° en la frase.
3.  Verifica si la frase es corta (menos de 20 caracteres) o larga.
4.  Imprim√≠ un mensaje diferente para cada caso.
"""

# 1. Ped√≠ al usuario que ingrese una frase
frase_usuario = input("Por favor, ingresa una frase: ")

# Med√≠ la longitud de la frase
longitud_frase = len(frase_usuario)

print(f"La frase tiene {longitud_frase} caracteres.")

# 2. Revis√° las condiciones con if/elif/else
if frase_usuario == "Carmen Marylin Rodriguez Perez":
  print("Hola " + frase_usuario)
elif frase_usuario == "Python":
  print("¬°Excelente! Tu frase menciona nuestro lenguaje de programaci√≥n favorito.")
else:
  print("Prueba, pruebita")

# Se puede usar el operador 'in' para ver si un texto est√° dentro de otro.

if "Python" in frase_usuario:
    print("¬°Excelente! Tu frase menciona nuestro lenguaje de programaci√≥n favorito.")
elif longitud_frase < 20:
    print("Es una frase corta, ¬°directa al punto!")
else:
    print("Una frase interesante y de buena longitud.")
#En este caso escrib√≠ Python, aunque tiene menos de 20 letras, al cumplir con el if me muestra la respuesta para esa condicion, por lo que no entra al elif que eval√∫a la logitud de la frase

"""## 5. Estructuras de Datos: Organizando nuestra Informaci√≥n

En PLN, necesitamos manejar colecciones de datos. Python nos ofrece varias formas de hacerlo:

* **Listas (`list`):** Colecciones ordenadas y modificables de elementos.
* **Tuplas (`tuple`):** Colecciones ordenadas pero INMODIFICABLES de elementos.
* **Diccionarios (`dict`):** Colecciones de pares clave-valor (como un diccionario real).
"""

# Listas (pueden modificarse)
# Usamos una lista para almacenar un conjunto de palabras clave.
# Las listas son √∫tiles para representar vocabularios o tokens.

palabras = ['hola', 'mundo', 'nlp', 'python', 'Hacer', 'pedir']
print("Lista original:", palabras)

# Agregar elemento
palabras.append('texto')
print("Despu√©s de append:", palabras)

# Remover elemento
palabras.remove('mundo')
print("Despu√©s de remove:", palabras)

# Acceder por √≠ndice
print("Primera palabra:", palabras[0])
print("√öltima palabra:", palabras[-1])

# Tuplas (NO pueden modificarse)
# Las tuplas se usan cuando los elementos no deben cambiar.
# En PLN, podr√≠an representar la posici√≥n (start, end) de una palabra en el texto.

coordenadas = (4, 5)
colores = ('rojo', 'verde', 'azul')

print("Tupla de coordenadas:", coordenadas)
print("Segundo color:", colores[0])

# Esto causar√≠a un error:
#colores[1] = 'amarillo'  # Descomenta para ver el error
#Las tuplas no se pueden modificar, si necesito una esctructura que requiere modificaci√≥n, entonces deber√≠a utilizar una lista

colores_lista = ['rojo', 'verde', 'azul']
colores_lista[1] = 'amarillo'
print("Lista de colores modificada:", colores_lista)

# Diccionarios (clave-valor)
#Un diccionario tiene un variable con un valor asignado
#üß† ¬øQu√© es frecuencia_palabras?
#Es un diccionario de Python, donde: üîë Las claves son palabras (por ejemplo: "nlp", "python")
#üî¢ Los valores son la cantidad de veces que aparecen en un texto

frecuencia_palabras = {'python': 15,
                       'nlp': 23,
                       'texto': 42}
print("Diccionario original:", frecuencia_palabras)

# Agregar nueva entrada
frecuencia_palabras['datos'] = 18
print("Despu√©s de agregar 'datos':", frecuencia_palabras)

# Acceder a valores
#.get() es un m√©todo seguro para consultar el valor de una clave en un diccionario.
#Si la clave existe, devuelve su valor.
#Si la clave no existe, devuelve el valor por defecto que vos especifiques.
print("Frecuencia de 'nlp':", frecuencia_palabras.get('nlp', 0))
print("Frecuencia de palabra inexistente:", frecuencia_palabras.get('inexistente', 0))

# Usamos el m√©todo .get() para obtener la frecuencia de la palabra 'nlp'.
# Si la palabra est√° en el diccionario, devuelve su valor.
# Si no estuviera, devolver√≠a 0 en lugar de generar un error.

# Si buscamos una palabra que no est√° en el diccionario, como 'inexistente',
# .get() nos devuelve 0 en lugar de lanzar un error.
# Esto es √∫til para evitar errores cuando analizamos grandes textos con muchas palabras diferentes.

# Condicionales con estructuras de datos
texto = "Python es excelente para NLP"
#texto = "Python es excelente para NLP, este es un texto de prueba"
palabras_texto = texto.split()

palabras_texto

if len(palabras_texto) > 3:
    print("El texto tiene m√°s de 3 palabras")
    if "NLP" in palabras_texto:
        print("Y adem√°s menciona NLP!")
    elif "Python" in palabras_texto:
        print("El texto menciona Python")
else:
    print("Texto corto sin palabras clave reconocidas")

# Bucles para procesar listas
texto = "Python es un lenguaje de programaci√≥n ampliamente utilizado en PLN, estetoscopio"

print("Palabras largas en el texto:")
for palabra in texto.split():
    if len(palabra) > 5:  # Palabras de m√°s de 5 letras
        print(f"- {palabra} ({len(palabra)} letras)")

# Recorremos el texto palabra por palabra (tokenizaci√≥n rudimentaria).
# Filtramos aquellas que superan cierta longitud.
# Este tipo de l√≥gica se usa para eliminar palabras irrelevantes (stopwords).

"""##Ejercicio Practico 2"""

#‚úèÔ∏è EJERCICIO PR√ÅCTICO 2: Contador de Palabras

texto = "Python es un lenguaje de programaci√≥n ampliamente utilizado en el procesamiento del lenguaje natural"

# 1. Convertir texto a min√∫sculas
texto = texto.lower()
texto

# 2. Dividir en palabras

palabras = texto.split()
print (palabras)

# 3. Contar frecuencia de cada palabra
frecuencias = {}

for palabra in palabras:
    frecuencias[palabra] = frecuencias.get(palabra, 0) + 1

frecuencias

#print("Frecuencias:", frecuencias)

"""---
## Glosario R√°pido de la Clase 1

* **Variable**: Un nombre que usamos para guardar un valor en la memoria del programa.
* **String (`str`)**: Un tipo de dato que representa texto. Se define con comillas (`"hola"`).
* **Integer (`int`)**: Tipo de dato para n√∫meros enteros, sin decimales (ej: `10`, `-3`).
* **Float (`float`)**: Tipo de dato para n√∫meros con decimales (ej: `9.5`, `3.1416`).
* **Boolean (`bool`)**: Un tipo de dato que solo tiene dos valores posibles: `True` (verdadero) o `False` (falso).
* **Operador**: Un s√≠mbolo que realiza una acci√≥n, como `+` para unir texto o `==` para comparar si dos cosas son iguales.
* **Condicional (`if`, `elif`, `else`)**: Una estructura que le permite a tu programa tomar decisiones y ejecutar diferentes bloques de c√≥digo seg√∫n se cumpla o no una condici√≥n.
* **Indentaci√≥n**: Los espacios al principio de una l√≠nea. En Python, es fundamental y define qu√© c√≥digo pertenece a un `if`, un bucle, etc.
* **Funci√≥n**: Un bloque de c√≥digo con nombre que realiza una tarea espec√≠fica (ej: `print()`, `len()`, `type()`).
---
"""